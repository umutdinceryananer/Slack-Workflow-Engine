def _handle_view_submission(ack, body, client, logger):



    view = body.get("view", {})



    metadata_raw = view.get("private_metadata", "{}")



    try:



        metadata = json.loads(metadata_raw)



    except json.JSONDecodeError:



        ack({"response_action": "errors", "errors": {"general": "Invalid workflow metadata."}})



        return







    workflow_type = metadata.get("workflow_type")



    if not workflow_type:



        ack({"response_action": "errors", "errors": {"general": "Workflow metadata missing."}})



        return







    try:



        definition = load_workflow_or_raise(workflow_type)



    except FileNotFoundError:



        ack({"response_action": "errors", "errors": {"general": "Workflow configuration not found."}})



        return



    except ValidationError:



        logger.exception("Invalid workflow definition during submission", extra={"workflow_type": workflow_type})



        ack({"response_action": "errors", "errors": {"general": "Workflow definition invalid."}})



        return







    state_payload = {"values": view.get("state", {}).get("values", {})}



    try:



        submission = parse_submission(state_payload, definition)



    except ValueError as exc:



        message = str(exc)



        block = "general"



        if ":" in message:



            block, message = message.split(":", 1)



            block = block.strip()



            message = message.strip()



        ack({"response_action": "errors", "errors": {block: message}})



        return







    user_id = body.get("user", {}).get("id", "unknown")



    canonical_payload = canonical_json(submission)



    request_key = compute_request_key(workflow_type, user_id, canonical_payload)



    try:



        request = save_request(



            workflow_type=workflow_type,



            created_by=user_id,



            payload_json=canonical_payload,



            request_key=request_key,



        )



        structlog.get_logger().info(



            "request_created",



            trace_id=request_id,



            workflow_type=workflow_type,



            request_id=request.id,



            user_id=user_id,



        )



    except DuplicateRequestError:



        ack(



            {



                "response_action": "errors",



                "errors": {



                    definition.fields[0].name if definition.fields else "general": "You already submitted this request."



                },



            }



        )



        return







    ack({"response_action": "clear"})



    run_async(



        publish_request_message,



        client=client,



        definition=definition,



        submission=submission,



        request_id=request.id,



        logger=logger,



    )
